---
layout: post
title:  "Division of Labor"
date:   2014-04-23 02:03:00PM

---

Early in my career as a programmer, I tried to make these perfect programs. I would craft these humming, precise automata that accomplished the functional requirements in as terse a fashion as possible. I'm serious; this code was so DRY that you got thirsty just reading it. In part, this was allowed by academic assignments that were essentially write-only: when you never had to go back and update your own code, you never learned good hygiene for writing maintainable code.

Part and parcel with this focus on non-redundancy was the notion of The One True Way. In order to keep the code simple, there would be one correct way to perform a given action (only one command line command for the task, or the button would appear in exactly one place). It turned out that this was very easy on me as the programmer, because I knew the exact incantation for each piece of functionality, and my code was easy for me to read because it only every did anything once.

And yet somehow at the same time I had always had an interest in user interface design. I would run other people's programs and find them obtuse and difficult to use and wonder what would drive them to be so mad. Embracing this, I jumped at the chance to take a Human-Computer Interaction course on designing usable interfaces (which, sadly, was purely discretionary for my Computer Science degree).

Unfortunately, this began a period from my Junior year of college through the early years of working in the real world, of a growing pressure in my head, the unsettling, stressful feeling of trying to act according to two contrasting beliefs at the same time that we call *cognitive dissonance*. I was trying to make good user interfaces that were easy to use, helped you learn how to use them, and were unobtrusive once you understood them. But at the same time, trying to create these concise, One True Way source files that were terse and never did anything twice.

What finally relieved the tension and allowed me to use both ideals in moderation is the notion of division of labor, or rather who's being made to do the work in the relationship. There is an incontrovertible relationship between producer and consumer of any work such that when one side does more work, the other may do less.

As an analogy, take a good book. Anyone can slap together 80,000 words and call it a novel. But the best books are the ones where the author does the work to, before putting pen to paper, conceiving of a rich setting for the story and planning the arcs of the characters and stories, writes the first draft, and then edits it ruthlessly until the final product is a finely-tuned, whirring narrative that fits together and enthralls you.

As a programmer, I was trying to do the least work required to meet functional specifications, which meant the user had to do more work. As a human being, I was trying to make the user do as little work as possible, which inevitably meant doing more work in the program to anticipate how the user will behave. What it took me so long to realize is that the logic to do the work of, for example, giving the user contextual suggestions based on location or time of day, is work. A lot of work. But that's also what makes some of the best programs so effortless to use. The producer has done the work so the consumer doesn't have to.

Let me leave you with one final case study: 
Â 
